Git Basics
==========

A basic overview of [Git](http://git-scm.com) accompanied by some tips,
tricks, and opinions on workflow for using it each day. This is no way
attempts to be a complete guide, just a simple set of heuristics to help
out beginners new to Git.

I personally learned Git best by watching Scott Chacon's
[videos](http://blip.tv/scott-chacon), reading through [Git's
documentation](http://git-scm.com/documentation), and browsing through
Chacon's [Pro Git book](http://git-scm.com/book). Remember, [Stack
Overflow](http://stackoverflow.com/tags/git/) is your friend, as well.


What is Git?
------------

This question has been covered numerous times all over the internet, but
I think of Git as a way of saving files at specific points in time. This
way, in case you mess anything up, you can go back to a specific point
and work from there.

Git also allows you to experiment freely with projects. If you had a car
project and wanted to add wings to it, you could do so by setting up a
`wings` branch. And, if anything went wrong, you could just rewind time
to a `commit` where the car previously worked perfectly.


Installation
------------

Git can easily be installed from [the official website](http://git-scm.com/).


Git Started
-----------

If you've never created a Git repository before, then let's start from
there on the command line (your computer's Terminal on Mac OS X).

First, we'll create a new project.

    $ mkdir letters
    $ cd letters

And we'll initialize this as a Git repository.

    $ git init

Now it's time to add some files. We'll do so using the `touch` command
and Unix bracket completion.

    $ touch README.md
    $ touch {a,b,c}.txt

You should now have four blank files in your repo. Let's go ahead and
create our first commit.

    $ git add --all
    $ git commit -m "First commit"

### Format

Github advocates a [simple commit message style](https://github.com/blog/926-shiny-new-commit-styles):

    Capitalized, short summary (less than 50 chars)

And, [Tim Pope advocates using present tense rather than past tense,
too](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).

    Write your commit message in the present tense: "Fix bug" and not "Fixed
    bug." This convention matches up with commit messages generated by
    commands like git merge and git revert.


Branching
---------

Our `letters` project is pretty cool so far, but what if we need to go
off on a tangent. Maybe three letters doesn't feel like enough, but we
don't want to screw up our current progress.

This is where branches come in handy. Let's create a new branch and add
a new letter file.

    $ git checkout -b more

So, we talked about branches, but what's with all this `checkout -b`
business? Well, using the `b` flag with the `checkout` command lets you
create new branches.

This seems weird, though. Shouldn't we use the `branch` command to add
new branches? Well, behind the scenes, it actually is being used. Here's
the long way of creating a new branch:

    $ git branch -l more
    $ git checkout more

Either way, you're going to have to `checkout` the new branch, so it's
just easier doing it all in one command.

Now, let's add a couple more files.

    $ touch {d,e}.txt
    $ touch f.md

Let's check the status of our currently staged files.

    $ git status

It should show three untracked files. And, while `status` is a nice
command, it uses up a lot of space. There's an easier way to see the
information you're after:

    $ git status -sb

The `s` flag creates short output, and the `b` flag gives us information
on the current branch we're in.

Currently, I like both the `d.txt` and `e.txt` files we've created, but
I'm unsure about committing the `f.md` file (since it ends with a Markdown
extension). Let's go ahead and add just the `.txt` files.

    $ git add *.txt

And, then we should double check that the `f.md` file wasn't added.

    $ git status -sb

In fact, it's good practice to **ALWAYS** check the status before making
a commit. And, since our double checking went okay, we can now make our
second commit.

    $ git commit -m "Add txt files"

We don't want to lose our progress by making the `f.md` file, though.
So, let's go ahead and create another branch (in fact, you should think
of branches as completely free -- feel free to make as many as you'd
like).

    $ git checkout -b "markdown"

Now that we're in the `markdown` branch, let's add the `f.md` file to
staging.

    $ git add f.md

And, lastly, we'll check our status before committing.

    $ git status -sb
    $ git commit -m "Add first markdown file"

### Switching Branches

We can now list out all our branches.

    $ git branch

In order to switch, we need to use the `checkout` command.

    $ git checkout more

This commit looks good (notice that the `f.md` file no longer exists in
this branch), so let's go ahead and `merge` it with the `master` branch.

    $ git checkout master
    $ git merge more

Awesome! Now your branches have been merged, and the new files should
appear. This should be the preferred way of developing new features -- I
think of the `master` branch as always being golden, and new features
should always be developed in separate branches.

We really don't need the `more` branch anymore, so let's go ahead and
delete that.

    $ git branch -d more

And, when we list out our branches, only two should appear now.

    $ git branch


Cloning
-------

The `clone` command allows you to work on projects that are already up
on the web (you'll mostly be using this with projects already up on
Github).

We don't necessarily need to use this command right now, but I'll go
ahead and leave a quick example.

    $ git clone git@github.com:codeforamerica/skillshares.git

This would clone the work currently done in the [Code for America
Skillshares repo](https://github.com/codeforamerica/skillshares) into a
directory named `skillshares`. If we didn't want that name, and instead
wanted a name like `Fred`, we could have run the following command:

    $ git clone git@github.com:codeforamerica/skillshares.git Fred

Alternatively, you could always `clone` and then `mv` the directory.

    $ git clone git@github.com:codeforamerica/skillshares.git
    $ mv skillshares Fred


Stashing
--------

Another useful command is `git stash`. This lets you "save" changes,
without really saving them.

For instance, let's create a new file.

    $ touch f.txt

And, let's add it to our staging area.

    $ git add --all

Then, we remember that we don't really need that file right now, but we
don't want to go ahead and create a new branch. It'd be nice to just put
it somewhere before we're ready to continue.

This is where `stash` comes in handy.

    $ git stash

Now we're back to the last commit, and the `f.txt` file is nowhere to be
seen. But, we decide we probably want it back -- this is where `stash
pop` can be used.

    $ git stash pop

And **boom**, we're back to having the `f.txt` file added to the current
staging area. You can double check this by using the `status` command
that we used earlier.

    $ git status -sb


Undo
----

Inevitably, you'll have to undo a previous commit. If it you haven't
already pushed to a remote (such as Github, Heroku, etc.) then `reset`
is probably the command you're looking for -- otherwise, you should
use `revert`.

With `reset`, you can delete a commit and keep the changes with the
`--soft` command. Alternatively, you can use the `--hard` flag to delete
a commit and delete the changes, as well.

Let's go ahead and commit the `f.txt` file, then play around with the
`reset` and `revert` commands.

    $ git status -sb
    $ git commit -m "Add f.txt file"

Now that we've made our commit, let's undo it.

    $ git reset HEAD^

The `^` character is shorthand for "previous commit" -- if you want a
more technical explanation, I'll be happy to explain it further. But,
now let's check out status:

   $ git status -sb

Notice the question marks next to `f.txt`? This means the file is
untracked, but the previous commit has been deleted. We've implicitly
used the `--soft` flag (our commit was deleted, but the files stayed the
same).

Let's go ahead and commit the file again.

    $ git add --all
    $ git commit -m "Add f.txt file"

Now, since we haven't pushed this code to a remote (such as Github or
Heroku), and we really don't want the `f.txt` file, let's go ahead and
do a `reset` with the `--hard` flag.

    $ git reset --hard HEAD~1

Notice that we used the `HEAD~1` keyword rather than `HEAD^`. Also, by
using the `--hard` flag, our commit and `f.txt` file should no longer
exist. We can check this by checking the status and commit log.

    $ git status -sb
    $ git log
